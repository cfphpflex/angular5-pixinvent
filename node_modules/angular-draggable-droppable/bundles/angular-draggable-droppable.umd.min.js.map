{
  "version": 3,
  "file": "angular-draggable-droppable.umd.min.js",
  "sources": [
    "ng://angular-draggable-droppable/src/draggable-helper.provider.ts",
    "ng://angular-draggable-droppable/src/draggable.directive.ts",
    "ng://angular-draggable-droppable/src/droppable.directive.ts",
    "ng://angular-draggable-droppable/src/drag-and-drop.module.ts"
  ],
  "sourcesContent": [
    "import { Subject } from 'rxjs/Subject';\n\nexport class DraggableHelper {\n  currentDrag: Subject<any> = new Subject();\n}\n",
    "import {\n  Directive,\n  OnInit,\n  ElementRef,\n  Renderer2,\n  Output,\n  EventEmitter,\n  Input,\n  OnDestroy,\n  OnChanges,\n  NgZone,\n  SimpleChanges\n} from '@angular/core';\nimport { Subject } from 'rxjs/Subject';\nimport { Observable } from 'rxjs/Observable';\nimport { merge } from 'rxjs/observable/merge';\nimport { map } from 'rxjs/operators/map';\nimport { mergeMap } from 'rxjs/operators/mergeMap';\nimport { takeUntil } from 'rxjs/operators/takeUntil';\nimport { take } from 'rxjs/operators/take';\nimport { takeLast } from 'rxjs/operators/takeLast';\nimport { pairwise } from 'rxjs/operators/pairwise';\nimport { share } from 'rxjs/operators/share';\nimport { filter } from 'rxjs/operators/filter';\nimport { DraggableHelper } from './draggable-helper.provider';\n\nexport interface Coordinates {\n  x: number;\n  y: number;\n}\n\nexport interface DragAxis {\n  x: boolean;\n  y: boolean;\n}\n\nexport interface SnapGrid {\n  x?: number;\n  y?: number;\n}\n\nexport type ValidateDrag = (coordinates: Coordinates) => boolean;\n\nexport interface PointerEvent {\n  clientX: number;\n  clientY: number;\n  event: MouseEvent | TouchEvent;\n}\n\nconst MOVE_CURSOR: string = 'move';\n\n@Directive({\n  selector: '[mwlDraggable]'\n})\nexport class DraggableDirective implements OnInit, OnChanges, OnDestroy {\n  /**\n   * an object of data you can pass to the drop event\n   */\n  @Input() dropData: any;\n\n  /**\n   * The axis along which the element is draggable\n   */\n  @Input() dragAxis: DragAxis = { x: true, y: true };\n\n  /**\n   * Snap all drags to an x / y grid\n   */\n  @Input() dragSnapGrid: SnapGrid = {};\n\n  /**\n   * Show a ghost element that shows the drag when dragging\n   */\n  @Input() ghostDragEnabled: boolean = true;\n\n  /**\n   * Allow custom behaviour to control when the element is dragged\n   */\n  @Input() validateDrag: ValidateDrag;\n\n  /**\n   * The cursor to use when dragging the element\n   */\n  @Input() dragCursor = MOVE_CURSOR;\n\n  /**\n   * Called when the element can be dragged along one axis and has the mouse or pointer device pressed on it\n   */\n  @Output() dragPointerDown = new EventEmitter<Coordinates>();\n\n  /**\n   * Called when the element has started to be dragged.\n   * Only called after at least one mouse or touch move event\n   */\n  @Output() dragStart = new EventEmitter<Coordinates>();\n\n  /**\n   * Called when the element is being dragged\n   */\n  @Output() dragging = new EventEmitter<Coordinates>();\n\n  /**\n   * Called after the element is dragged\n   */\n  @Output() dragEnd = new EventEmitter<Coordinates>();\n\n  /**\n   * @hidden\n   */\n  pointerDown: Subject<PointerEvent> = new Subject();\n\n  /**\n   * @hidden\n   */\n  pointerMove: Subject<PointerEvent> = new Subject();\n\n  /**\n   * @hidden\n   */\n  pointerUp: Subject<PointerEvent> = new Subject();\n\n  private eventListenerSubscriptions: {\n    mousemove?: () => void;\n    mousedown?: () => void;\n    mouseup?: () => void;\n    mouseenter?: () => void;\n    mouseleave?: () => void;\n    touchstart?: () => void;\n    touchmove?: () => void;\n    touchend?: () => void;\n    touchcancel?: () => void;\n  } = {};\n\n  /**\n   * @hidden\n   */\n  constructor(\n    public element: ElementRef,\n    private renderer: Renderer2,\n    private draggableHelper: DraggableHelper,\n    private zone: NgZone\n  ) {}\n\n  ngOnInit(): void {\n    this.checkEventListeners();\n\n    const pointerDrag: Observable<any> = this.pointerDown\n      .pipe(filter(() => this.canDrag()))\n      .pipe(\n        mergeMap((pointerDownEvent: PointerEvent) => {\n          const currentDrag: Subject<any> = new Subject();\n\n          this.zone.run(() => {\n            this.dragPointerDown.next({ x: 0, y: 0 });\n          });\n\n          const pointerMove: Observable<Coordinates> = this.pointerMove\n            .pipe(\n              map((pointerMoveEvent: PointerEvent) => {\n                pointerMoveEvent.event.preventDefault();\n\n                return {\n                  currentDrag,\n                  x: pointerMoveEvent.clientX - pointerDownEvent.clientX,\n                  y: pointerMoveEvent.clientY - pointerDownEvent.clientY,\n                  clientX: pointerMoveEvent.clientX,\n                  clientY: pointerMoveEvent.clientY\n                };\n              })\n            )\n            .pipe(\n              map((moveData: Coordinates) => {\n                if (this.dragSnapGrid.x) {\n                  moveData.x =\n                    Math.floor(moveData.x / this.dragSnapGrid.x) *\n                    this.dragSnapGrid.x;\n                }\n\n                if (this.dragSnapGrid.y) {\n                  moveData.y =\n                    Math.floor(moveData.y / this.dragSnapGrid.y) *\n                    this.dragSnapGrid.y;\n                }\n\n                return moveData;\n              })\n            )\n            .pipe(\n              map((moveData: Coordinates) => {\n                if (!this.dragAxis.x) {\n                  moveData.x = 0;\n                }\n\n                if (!this.dragAxis.y) {\n                  moveData.y = 0;\n                }\n\n                return moveData;\n              })\n            )\n            .pipe(\n              filter(\n                ({ x, y }) => !this.validateDrag || this.validateDrag({ x, y })\n              )\n            )\n            .pipe(takeUntil(merge(this.pointerUp, this.pointerDown)))\n            .pipe(share());\n\n          pointerMove.pipe(take(1)).subscribe(() => {\n            pointerDownEvent.event.preventDefault();\n\n            this.zone.run(() => {\n              this.dragStart.next({ x: 0, y: 0 });\n            });\n\n            this.setCursor(this.dragCursor);\n\n            this.draggableHelper.currentDrag.next(currentDrag);\n          });\n\n          pointerMove.pipe(takeLast(1)).subscribe(({ x, y }) => {\n            this.zone.run(() => {\n              this.dragEnd.next({ x, y });\n            });\n            currentDrag.complete();\n            this.setCssTransform(null);\n            if (this.ghostDragEnabled) {\n              this.renderer.setStyle(\n                this.element.nativeElement,\n                'pointerEvents',\n                null\n              );\n            }\n          });\n\n          return pointerMove;\n        })\n      )\n      .pipe(share());\n\n    merge(\n      pointerDrag.pipe(take(1)).pipe(map(value => [, value])),\n      pointerDrag.pipe(pairwise())\n    )\n      .pipe(\n        filter(([previous, next]) => {\n          if (!previous) {\n            return true;\n          }\n          return previous.x !== next.x || previous.y !== next.y;\n        })\n      )\n      .pipe(map(([previous, next]) => next))\n      .subscribe(({ x, y, currentDrag, clientX, clientY }) => {\n        this.zone.run(() => {\n          this.dragging.next({ x, y });\n        });\n        if (this.ghostDragEnabled) {\n          this.renderer.setStyle(\n            this.element.nativeElement,\n            'pointerEvents',\n            'none'\n          );\n        }\n        this.setCssTransform(`translate(${x}px, ${y}px)`);\n        currentDrag.next({\n          clientX,\n          clientY,\n          dropData: this.dropData\n        });\n      });\n  }\n\n  ngOnChanges(changes: SimpleChanges): void {\n    if (changes['dragAxis']) {\n      this.checkEventListeners();\n    }\n  }\n\n  ngOnDestroy(): void {\n    this.unsubscribeEventListeners();\n    this.pointerDown.complete();\n    this.pointerMove.complete();\n    this.pointerUp.complete();\n  }\n\n  private checkEventListeners(): void {\n    const canDrag: boolean = this.canDrag();\n    const hasEventListeners: boolean =\n      Object.keys(this.eventListenerSubscriptions).length > 0;\n\n    if (canDrag && !hasEventListeners) {\n      this.zone.runOutsideAngular(() => {\n        this.eventListenerSubscriptions.mousedown = this.renderer.listen(\n          this.element.nativeElement,\n          'mousedown',\n          (event: MouseEvent) => {\n            this.onMouseDown(event);\n          }\n        );\n\n        this.eventListenerSubscriptions.mouseup = this.renderer.listen(\n          'document',\n          'mouseup',\n          (event: MouseEvent) => {\n            this.onMouseUp(event);\n          }\n        );\n\n        this.eventListenerSubscriptions.touchstart = this.renderer.listen(\n          this.element.nativeElement,\n          'touchstart',\n          (event: TouchEvent) => {\n            this.onTouchStart(event);\n          }\n        );\n\n        this.eventListenerSubscriptions.touchend = this.renderer.listen(\n          'document',\n          'touchend',\n          (event: TouchEvent) => {\n            this.onTouchEnd(event);\n          }\n        );\n\n        this.eventListenerSubscriptions.touchcancel = this.renderer.listen(\n          'document',\n          'touchcancel',\n          (event: TouchEvent) => {\n            this.onTouchEnd(event);\n          }\n        );\n\n        this.eventListenerSubscriptions.mouseenter = this.renderer.listen(\n          this.element.nativeElement,\n          'mouseenter',\n          () => {\n            this.onMouseEnter();\n          }\n        );\n\n        this.eventListenerSubscriptions.mouseleave = this.renderer.listen(\n          this.element.nativeElement,\n          'mouseleave',\n          () => {\n            this.onMouseLeave();\n          }\n        );\n      });\n    } else if (!canDrag && hasEventListeners) {\n      this.unsubscribeEventListeners();\n    }\n  }\n\n  private onMouseDown(event: MouseEvent): void {\n    if (!this.eventListenerSubscriptions.mousemove) {\n      this.eventListenerSubscriptions.mousemove = this.renderer.listen(\n        'document',\n        'mousemove',\n        (mouseMoveEvent: MouseEvent) => {\n          this.pointerMove.next({\n            event: mouseMoveEvent,\n            clientX: mouseMoveEvent.clientX,\n            clientY: mouseMoveEvent.clientY\n          });\n        }\n      );\n    }\n    this.pointerDown.next({\n      event,\n      clientX: event.clientX,\n      clientY: event.clientY\n    });\n  }\n\n  private onMouseUp(event: MouseEvent): void {\n    if (this.eventListenerSubscriptions.mousemove) {\n      this.eventListenerSubscriptions.mousemove();\n      delete this.eventListenerSubscriptions.mousemove;\n    }\n    this.pointerUp.next({\n      event,\n      clientX: event.clientX,\n      clientY: event.clientY\n    });\n  }\n\n  private onTouchStart(event: TouchEvent): void {\n    if (!this.eventListenerSubscriptions.touchmove) {\n      this.eventListenerSubscriptions.touchmove = this.renderer.listen(\n        'document',\n        'touchmove',\n        (touchMoveEvent: TouchEvent) => {\n          this.pointerMove.next({\n            event: touchMoveEvent,\n            clientX: touchMoveEvent.targetTouches[0].clientX,\n            clientY: touchMoveEvent.targetTouches[0].clientY\n          });\n        }\n      );\n    }\n    this.pointerDown.next({\n      event,\n      clientX: event.touches[0].clientX,\n      clientY: event.touches[0].clientY\n    });\n  }\n\n  private onTouchEnd(event: TouchEvent): void {\n    if (this.eventListenerSubscriptions.touchmove) {\n      this.eventListenerSubscriptions.touchmove();\n      delete this.eventListenerSubscriptions.touchmove;\n    }\n    this.pointerUp.next({\n      event,\n      clientX: event.changedTouches[0].clientX,\n      clientY: event.changedTouches[0].clientY\n    });\n  }\n\n  private onMouseEnter(): void {\n    this.setCursor(this.dragCursor);\n  }\n\n  private onMouseLeave(): void {\n    this.setCursor(null);\n  }\n\n  private setCssTransform(value: string | null): void {\n    if (this.ghostDragEnabled) {\n      const transformAttributes = [\n        'transform',\n        '-webkit-transform',\n        '-ms-transform',\n        '-moz-transform',\n        '-o-transform'\n      ];\n      transformAttributes.forEach(transformAttribute => {\n        this.renderer.setStyle(\n          this.element.nativeElement,\n          transformAttribute,\n          value\n        );\n      });\n    }\n  }\n\n  private canDrag(): boolean {\n    return this.dragAxis.x || this.dragAxis.y;\n  }\n\n  private setCursor(value: string | null): void {\n    this.renderer.setStyle(this.element.nativeElement, 'cursor', value);\n  }\n\n  private unsubscribeEventListeners(): void {\n    Object.keys(this.eventListenerSubscriptions).forEach(type => {\n      (this as any).eventListenerSubscriptions[type]();\n      delete (this as any).eventListenerSubscriptions[type];\n    });\n  }\n}\n",
    "import {\n  Directive,\n  OnInit,\n  ElementRef,\n  OnDestroy,\n  Output,\n  EventEmitter,\n  NgZone\n} from '@angular/core';\nimport { Subject } from 'rxjs/Subject';\nimport { Subscription } from 'rxjs/Subscription';\nimport { Observable } from 'rxjs/Observable';\nimport { distinctUntilChanged } from 'rxjs/operators/distinctUntilChanged';\nimport { pairwise } from 'rxjs/operators/pairwise';\nimport { filter } from 'rxjs/operators/filter';\nimport { map } from 'rxjs/operators/map';\nimport { mergeMap } from 'rxjs/operators/mergeMap';\nimport { DraggableHelper } from './draggable-helper.provider';\n\nfunction isCoordinateWithinRectangle(\n  clientX: number,\n  clientY: number,\n  rect: ClientRect\n): boolean {\n  return (\n    clientX >= rect.left &&\n    clientX <= rect.right &&\n    clientY >= rect.top &&\n    clientY <= rect.bottom\n  );\n}\n\nexport interface DropData {\n  dropData: any;\n}\n\n@Directive({\n  selector: '[mwlDroppable]'\n})\nexport class DroppableDirective implements OnInit, OnDestroy {\n  /**\n   * Called when a draggable element starts overlapping the element\n   */\n  @Output() dragEnter = new EventEmitter<DropData>();\n\n  /**\n   * Called when a draggable element stops overlapping the element\n   */\n  @Output() dragLeave = new EventEmitter<DropData>();\n\n  /**\n   * Called when a draggable element is moved over the element\n   */\n  @Output() dragOver = new EventEmitter<DropData>();\n\n  /**\n   * Called when a draggable element is dropped on this element\n   */\n  @Output() drop = new EventEmitter<DropData>();\n\n  currentDragSubscription: Subscription;\n\n  constructor(\n    private element: ElementRef,\n    private draggableHelper: DraggableHelper,\n    private zone: NgZone\n  ) {}\n\n  ngOnInit(): void {\n    interface CurrentDragData {\n      clientX: number;\n      clientY: number;\n      dropData: any;\n    }\n\n    this.currentDragSubscription = this.draggableHelper.currentDrag.subscribe(\n      (drag: Subject<CurrentDragData>) => {\n        const droppableRectangle: ClientRect = this.element.nativeElement.getBoundingClientRect();\n\n        let currentDragDropData: any;\n        const overlaps = drag.pipe(\n          map(({ clientX, clientY, dropData }) => {\n            currentDragDropData = dropData;\n            return isCoordinateWithinRectangle(\n              clientX,\n              clientY,\n              droppableRectangle\n            );\n          })\n        );\n\n        const overlapsChanged = overlaps.pipe(distinctUntilChanged());\n\n        let dragOverActive: boolean; // TODO - see if there's a way of doing this via rxjs\n\n        overlapsChanged\n          .pipe(filter(overlapsNow => overlapsNow))\n          .subscribe(() => {\n            dragOverActive = true;\n            this.zone.run(() => {\n              this.dragEnter.next({\n                dropData: currentDragDropData\n              });\n            });\n          });\n\n        overlaps.pipe(filter(overlapsNow => overlapsNow)).subscribe(() => {\n          this.zone.run(() => {\n            this.dragOver.next({\n              dropData: currentDragDropData\n            });\n          });\n        });\n\n        overlapsChanged\n          .pipe(pairwise())\n          .pipe(\n            filter(([didOverlap, overlapsNow]) => didOverlap && !overlapsNow)\n          )\n          .subscribe(() => {\n            dragOverActive = false;\n            this.zone.run(() => {\n              this.dragLeave.next({\n                dropData: currentDragDropData\n              });\n            });\n          });\n\n        drag.pipe(mergeMap(() => overlaps)).subscribe({\n          complete: () => {\n            if (dragOverActive) {\n              this.zone.run(() => {\n                this.drop.next({\n                  dropData: currentDragDropData\n                });\n              });\n            }\n          }\n        });\n      }\n    );\n  }\n\n  ngOnDestroy(): void {\n    this.currentDragSubscription.unsubscribe();\n  }\n}\n",
    "import { NgModule, ModuleWithProviders } from '@angular/core';\nimport { DraggableDirective } from './draggable.directive';\nimport { DroppableDirective } from './droppable.directive';\nimport { DraggableHelper } from './draggable-helper.provider';\n\n@NgModule({\n  declarations: [DraggableDirective, DroppableDirective],\n  exports: [DraggableDirective, DroppableDirective]\n})\nexport class DragAndDropModule {\n  static forRoot(): ModuleWithProviders {\n    return {\n      ngModule: DragAndDropModule,\n      providers: [DraggableHelper]\n    };\n  }\n}\n"
  ],
  "names": [
    "this",
    "dragAxis",
    "x",
    "y",
    "dragStart",
    "EventEmitter",
    "eventListenerSubscriptions",
    "DraggableDirective",
    "prototype",
    "ngOnInit",
    "_this",
    "pipe",
    "mergeMap$1",
    "pointerDownEvent",
    "currentDrag",
    "Subject$1",
    "zone",
    "run",
    "dragPointerDown",
    "next",
    "pointerMove",
    "Subject",
    "map$1",
    "pointerMoveEvent",
    "event",
    "preventDefault",
    "clientX",
    "clientY",
    "moveData",
    "dragSnapGrid",
    "Math",
    "floor",
    "filter$1",
    "_a",
    "validateDrag",
    "filter",
    "merge$1",
    "pointerUp",
    "pointerDown",
    "takeUntil",
    "take$1",
    "subscribe",
    "setCursor",
    "dragCursor",
    "draggableHelper",
    "takeLast$1",
    "dragEnd",
    "complete",
    "setCssTransform",
    "ghostDragEnabled",
    "renderer",
    "setStyle",
    "element",
    "nativeElement",
    "share",
    "merge",
    "pointerDrag",
    "take",
    "map",
    "previous",
    "dragging",
    "ngOnDestroy",
    "checkEventListeners",
    "canDrag",
    "hasEventListeners",
    "Object",
    "keys",
    "length",
    "runOutsideAngular",
    "mousedown",
    "listen",
    "onMouseDown",
    "mouseup",
    "onMouseUp",
    "touchstart",
    "onTouchStart",
    "touchend",
    "onTouchEnd",
    "touchcancel",
    "mouseenter",
    "onMouseEnter",
    "mouseleave",
    "onMouseLeave",
    "mousemove",
    "mouseMoveEvent",
    "touchmove",
    "touchMoveEvent",
    "targetTouches",
    "touches",
    "changedTouches",
    "value",
    "forEach",
    "transformAttribute",
    "unsubscribeEventListeners",
    "selector",
    "ctorParameters",
    "type",
    "ElementRef",
    "Renderer2",
    "DraggableHelper",
    "NgZone",
    "Input",
    "DroppableDirective",
    "dragLeave",
    "dragOver",
    "drop",
    "currentDragSubscription",
    "drag",
    "currentDragDropData",
    "dragOverActive",
    "droppableRectangle",
    "getBoundingClientRect",
    "overlaps",
    "dropData",
    "rect",
    "overlapsChanged",
    "distinctUntilChanged$1",
    "overlapsNow",
    "dragEnter",
    "pairwise$1",
    "didOverlap",
    "decorators",
    "propDecorators",
    "Output",
    "DragAndDropModule"
  ],
  "mappings": "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"
}
